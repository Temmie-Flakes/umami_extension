{"version":3,"sources":["umami.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"umami.js","sourcesContent":["(function () {\n\n    console.clear();\n    if (typeof browser === \"undefined\") {\n        if (typeof chrome === \"undefined\") {\n            console.log(\"UMAMI\", \"COULD NOT FIND BROWSER OR CHROME\");\n            return;\n        }\n        browser = chrome;\n    }\n\n    // window.setInterval(() => {\n    //     browser.runtime.sendMessage({\n    //         from_background: \"BEEP\",\n    //     });\n    // }, 1000);\n\n    browser.runtime.onMessage.addListener(onMessage);\n\n    const umamiTabs = {};\n\n    const sendToTabs = (type, data) => {\n        browser.tabs.query({}).then(tabs => {\n            const tabIDs = tabs.map(tab => parseInt(tab.id));\n            umamiTabs.forEach((tab, k) => {\n                if (tabIDs.includes(parseInt(tab.id))) {\n                    browser.tabs.sendMessage(tab.id, { type: type, data: data, src: \"umami-background\" });\n                } else {\n                    delete umamiTabs[k];\n                }\n            });\n        });\n    };\n\n    s2t = sendToTabs;\n\n    console.log(\"UMAMI\", \"INIT\");\n\n    const bulkDLs = {};\n    const activeBulkDLs = {};\n    let bulkDlInterval = null;\n\n    const cleanFileName = name => name.replace(/[^a-z0-9 \\\\\\/\\(\\)\\.\\-\\[\\]]/gi, '_');\n    const cleanFolderName = name => name.replace(/[^a-z0-9 \\(\\)\\.\\-\\[\\]]/gi, '_');\n\n    const bulkDL = (files, folder, root, id) => {\n        files = JSON.parse(JSON.stringify(files));\n\n        const key = \"bdl\" + Date.now();\n\n        bulkDLs[key] = {\n            id: id,\n            root: root || \"\",\n            folder: folder,\n            files: files,\n            count: files.length,\n            done: [],\n        };\n\n        if (bulkDlInterval === null) {\n            window.setInterval(startBulkDL, 200);\n        }\n    };\n\n    const completeBulkDL = (key) => {\n        browser.downloads.show(bulkDLs[key].done[0]);\n        delete bulkDLs[key];\n    };\n\n    const completeBulkDLItem = (obj) => {\n        const id = obj.id;\n        const key = activeBulkDLs[id];\n        const dl = bulkDLs[key];\n        dl.done.push(id);\n        browser.downloads.erase({ id: id }).then(() => {\n            console.log(\"ERASED\", id);\n            sendToTabs(\"bulk_dl_step\", { id: dl.id, count: dl.count, done: dl.done.length, name: dl.folder, file: \"file\" });\n            if (bulkDLs[key].done.length === bulkDLs[key].count) {\n                completeBulkDL(key);\n            }\n            delete activeBulkDLs[id];\n        });\n    };\n\n    const pathCombine = (arr) => arr.join(\"/\").split(\"/\").map(val => val.trim()).filter(val => val.length).join(\"/\");\n\n    const getBulkDL = () => {\n        const key = Object.keys(bulkDLs).sort().shift();\n        if (typeof key === \"undefined\") return null;\n        const result = { key: key };\n        const folder = cleanFolderName(bulkDLs[key].folder);\n        const root = cleanFolderName(bulkDLs[key].root);\n        const file = bulkDLs[key].files.shift();\n        if (typeof file === \"undefined\") {\n            result.file = null;\n        } else {\n            result.url = file.url;\n            result.file = pathCombine([root, folder, cleanFileName(file.name)]);\n        }\n        return result;\n    };\n\n    const startBulkDL = () => {\n        if (Object.keys(activeBulkDLs).length >= 5) {\n            return;\n        }\n        const dl = getBulkDL();\n        if (dl === null) {\n            window.clearInterval(bulkDlInterval);\n            bulkDlInterval = null;\n            return;\n        }\n        if (dl.file === null) {\n            return;\n        }\n        const fake = \"p\" + Date.now();\n        activeBulkDLs[fake] = false;\n        browser.downloads.download({\n            url: dl.url,\n            filename: dl.file,\n            saveAs: false,\n            conflictAction: browser.downloads.FilenameConflictAction.OVERWRITE,\n        }).then((dlID) => {\n            activeBulkDLs[dlID] = dl.key;\n            delete activeBulkDLs[fake];\n        }).catch(e => {\n            delete activeBulkDLs[fake];\n        });\n    };\n\n    const bulkDLChange = (obj) => {\n        const id = obj.id;\n        if (typeof activeBulkDLs[id] === \"string\") {\n            if (obj.state.current === \"complete\") {\n                window.setTimeout(() => {\n                    completeBulkDLItem(obj);\n                }, 500);\n            }\n        }\n    };\n\n    browser.downloads.onChanged.addListener(bulkDLChange);\n\n    let commands = {\n        openTab: (cmd) => {\n            return new Promise((res, rej) => {\n                browser.tabs.create({\n                    active: true,\n                    url: cmd.url,\n                });\n                res(\"done\");\n            });\n        },\n        download: (cmd) => {\n            return new Promise((res, rej) => {\n                browser.downloads.download({\n                    url: cmd.url,\n                    filename: cmd.filename,\n                });\n                res(\"done\");\n            });\n        },\n        bulk_download: cmd => {\n            bulkDL(cmd.files, cmd.foldername, cmd.root, cmd.id);\n            return Promise.resolve();\n        },\n        request: request,\n        openUri: data => {\n            return commands.openTab({ url: data.uri });\n        },\n        ping: () => Promise.resolve(),\n    };\n\n    // commands.openTab(\n    //     {\n    //         url: 'tg://msg_url?url=https://static1.e926.net/data/sample/59/7d/597dab4e8ff4bfdd0fc87878beb485c9.jpg&text=LOOK NOT PORN'\n    //     }\n    // );\n\n    function runCommand(type, data) {\n        if (commands.hasOwnProperty(type)) {\n            if (typeof commands[type] === \"function\") {\n                return commands[type](data);\n            }\n        }\n        console.log(\"MISSING COMMAND\", type);\n        return Promise.reject({ err: \"NO FUNC TYPE\" });\n    }\n\n    function onMessage(message, sender, sr) {\n        const { type, data, src } = message;\n        if (src !== \"umami-content\") return;\n        umamiTabs[sender.tab.id] = sender.tab;\n        try {\n            return new Promise((resolve, reject) => {\n                try {\n                    runCommand(type, data)\n                        .then(resolve)\n                        .catch(reject);\n                } catch (e) {\n                    console.log(\"onmsg prom error\", e);\n                    reject(e);\n                }\n            });\n        } catch (e) {\n            console.log(\"onmsg error\", e);\n            return Promise.reject(e);\n        }\n    }\n\n    function processRequest() {\n        const request = pendingReqs.shift();\n        const data = request.data;\n        const resolve = request.resolve;\n        const reject = request.reject;\n        let url = data.url;\n        let params = data.params || {};\n        if (params.query) {\n            url += (url.indexOf('?') === -1 ? '?' : '&') + queryParams(params.query);\n            delete params.query;\n        }\n\n        fetch(url, params)\n            .then(requestResponseCast)\n            .then(resolve)\n            .catch(reject)\n            .finally(() => {\n                reqTimeout = null;\n                if (pendingReqs.length > 0) {\n                    reqTimeout = setTimeout(processRequest, 1000);\n                }\n            });\n    }\n\n    let reqTimeout = null;\n    const pendingReqs = [];\n\n    function request(data) {\n        return new Promise((resolve, reject) => {\n            pendingReqs.push({\n                data: data,\n                resolve: resolve,\n                reject: reject,\n            });\n            if (reqTimeout === null) {\n                reqTimeout = setTimeout(processRequest, 1);\n            }\n        });\n    }\n\n    function requestResponseCast(response) {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n            try {\n                return response.json();\n            } catch (e) {\n\n            }\n        }\n        return response.text();\n    }\n\n    function queryParams(params) {\n        return Object.keys(params)\n            .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))\n            .join('&');\n    }\n\n    // function notify(msg) {\n    //     browser.notifications.create({\n    //         \"type\": \"basic\",\n    //         \"iconUrl\": browser.extension.getURL(\"icons/salt.png\"),\n    //         \"title\": \"You clicked a link!\",\n    //         \"message\": msg\n    //     });\n    // }\n\n})();"]}